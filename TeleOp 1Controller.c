#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     rightDrive,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     leftDrive,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     lift,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     flag,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     arm,           tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     bucket,        tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    dumper,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    flagMount,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    flagRaiser,           tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "drive.h" //include for assisted TeleOp

void initializeRobot()
{
	servo[dumper] = 233;
	servo[flagMount] = 17;
	return;
	nMotorEncoder[rightDrive] = 0;
}

//ranges: motor power = -100 to +100, joystick = -128 to +128.
//For more prescise movement we normalize the values
const float multiplier = 0.5078;// used to normalize joystick values
const int driveLowerThreshold = 15;//prevents motors from straining at very low power if the joystick is not at center
int drivePowerBoost1 = 80;
int drivePowerBoost2 = 100;
//int driveUpperThreshold = 85;
bool flagOut = false;
bool dumperOut = false;

const int bucketStartSpeed = 50;
const int bucketScoopAngle = 100;
const int bucketDumpAngle = 120;
const int bucketGearRatio = 2;
const int bucketDumpTics = 4*bucketGearRatio*bucketDumpAngle;
const int bucketScoopTics = 4*bucketGearRatio*bucketScoopAngle;
const int bucketDumpSlope = bucketStartSpeed/bucketDumpTics;
const int bucketScoopSlope = bucketStartSpeed/bucketScoopTics;
task main()
{
	initializeRobot();
	waitForStart();   // wait for start of tele-op phase
	nMotorEncoder[bucket] = 0;
	nMotorEncoder[arm] = 0;

	nMotorEncoder[rightDrive] = 0;
	nMotorEncoder[leftDrive] = 0;
	while (true)//infinite loop
	{
		bool isFlagExtended = false;
		bool waitingForRelease = false;
		getJoystickSettings(joystick);	//retrieves current joystick positions
		//Drive Code

        if(joy1Btn(7))
            motor[leftDrive] = 75;
        else
            motor[leftDrive] = 0;
        if(joy1Btn(8))
            motor[rightDrive] = rightPower;
        else
            motor[leftDrive] = 0;



		//Lift code
		if(abs(joystick.joy1_y2) > 30){	//if the absolute value is > 30
			if(joystick.joy1_y2 > 0){	//if it's a positive #
				motor[lift] = 70;	//set to low power
			}
			else{
				motor[lift] = -40;
			}
		}//end of absolute value if
		else{
			motor[lift] = 0;
		}


		//Arm code
		if(abs(joystick.joy1_y1) > 30){			//if absolute value of joystick is less than 30
			if(joy1Btn(5) == 1){
				if( (abs(nMotorEncoder[arm]) >= 9000) && joystick.joy1_y1 > 0)
						motor[arm] = 0;
				else
					motor[arm] = joystick.joy1_y1*85/abs(joystick.joy1_y1);
			}
			else{
				if((abs(nMotorEncoder[arm]) >= 9000) && joystick.joy1_y1 > 0)
						motor[arm] = 0;
				else
					motor[arm] = joystick.joy1_y1*100/abs(joystick.joy1_y1);
			}
		}
		else{
			motor[arm] = 0;
		}
		//Bucket code
        if(joystick.joy1_TopHat == 0){ //if tophat is pressed up (0)
			motor[bucket] = 40; //else power =20  //35 without PID
		}
		//this section makes the bucket go towards the back of the robot
		else if(joystick.joy1_TopHat == 4){ //if prev is false and tophat is pressed down (4)
			motor[bucket] = -40; //else power = -20 //35 without PID
		}
		else{
			motor[bucket] = 0;
		}
		//Flag code
		if(joy1Btn(3)) {
			servo[flagMount] = 134;
			flagOut = true;
		}
		else if(joy1Btn(4) && flagOut == true){
			servo[flagMount] = 134;
			motor[flag] = 100;
		}
		else if(joy1Btn(2) && flagOut == true){
			servo[flagMount] = 134;
			motor[flag] = 15;
		}
		else if(joy1Btn(1)){
			servo[flagMount] = 17;
			flagOut = false;
		}
		else{
			motor[flag] = 0;
		}
		//nudge code
		if(joy1Btn(5)) {
			moveBackwardInches(25, 1, false, LEFTENCODER);
		}
		//dumper code for TeleOp
		if(joy1Btn(5) && dumperOut == false) {
			servo[dumper] = 30;
			ClearTimer(T4);//delay for boolean setting
			dumperOut = true;//limits to one use per match
		}
		else if(time1[T4]>3000){//wait for correct timer amount
			servo[dumper] = 233;//reset servo
		}
	}//end bracket of loop
}//end task main bracket
